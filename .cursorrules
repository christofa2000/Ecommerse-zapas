# .cursorrules ‚Äî Proyecto "zapatillas"

# Objetivo: Web estilo Allbirds con Next.js + TS + Tailwind v4 + shadcn/ui + Framer Motion + Jest + Playwright

# + Backend API en Node.js + TypeScript (NestJS/Express) con PostgreSQL + Prisma

# Principios clave: tipado estricto, accesibilidad, performance, estilos centralizados y arquitectura limpia (front + back).

## Lenguaje y stack (frontend)

- Usar TypeScript estricto. Prohibido `any` expl√≠cito.
- React + Next.js App Router (TSX con Server/Client Components bien declarados).
- UI: Tailwind CSS v4 con **toda** la personalizaci√≥n en `app/globals.css`.
- Componentes: shadcn/ui (radix) para piezas reutilizables. Extender s√≥lo v√≠a clases utilitarias o tokens globales.
- Animaciones: framer-motion (sin abusar).
- Estado: preferir props lifting y server actions; usar `zustand` s√≥lo cuando sea realmente necesario.
- Validaci√≥n: `zod` para inputs y esquemas.

## Estilos (regla de oro ‚Äî frontend)

- **Prohibido** definir colores, tama√±os, tipograf√≠as o sombras dentro de componentes.
- Cualquier cambio de color, spacing, tipograf√≠a o radius debe venir de **tokens CSS** en `app/globals.css`.
- Si falta un token, agr√©galo a `:root` en `globals.css` y √∫salo con Tailwind utilities (ej.: `text-[var(--fg)]`).
- Evitar `style={{ ... }}` salvo casos puntuales de optimizaci√≥n o variables din√°micas justificadas.

## Accesibilidad (frontend)

- Siempre `alt` descriptivo en im√°genes, `aria-*` cuando corresponda.
- Contraste AA m√≠nimo. Validar contenido din√°mico con `role`/`aria-live` cuando aplique.
- Focus visible: usar utilidades `.focus-ring` definidas en `globals.css`.

## Performance (frontend)

- Im√°genes con `next/image`, tama√±os y `priority` s√≥lo en hero.
- Evitar renders innecesarios, memoizar donde aporte.
- C√≥digo dividido por rutas/segmentos; cargar terceros on-demand.

## Testing (frontend)

- Unit/Integration con Jest + RTL (sin mocks innecesarios).
- E2E con Playwright: flujos cr√≠ticos (home, PLP, PDP, cart).
- Todo bug reproducido debe ir acompa√±ado de test.

## Convenciones (frontend)

- Alias `@/*` obligatorio.
- Nombres: componentes `PascalCase`, hooks `use*`, utils `camelCase`.
- Server/Client: anotar `"use client"` s√≥lo cuando sea imprescindible.
- No exponer secretos del lado cliente.

## Entregables de dise√±o (frontend)

- Tipograf√≠as, escala, paleta y sombras est√°n en `globals.css`. Cualquier variante nueva ‚Üí `:root`.
- shadcn/ui: sobrescribir con utilidades basadas en tokens, nunca con valores hardcodeados.

---

## Backend API (Node.js + TypeScript)

### Stack backend

- Runtime: Node.js 20+.
- Lenguaje: TypeScript estricto (`strict: true`).
- Framework HTTP: NestJS (preferido) o Express + Fastify con arquitectura modular clara.
- ORM: Prisma + PostgreSQL.
- Validaci√≥n: `zod` para inputs y esquemas de dominio (no mezclar enfoques en el mismo endpoint).
- Auth: JWT (access + refresh tokens).
- Testing: Jest + Supertest (tests unitarios + integraci√≥n).

### Arquitectura backend

- Organizar el backend en m√≥dulos de dominio:
  - `products` (cat√°logo de zapatillas).
  - `users` (usuarios, perfiles).
  - `auth` (login, registro, refresh).
  - `orders` (√≥rdenes/checkout).
- Estructura por m√≥dulo (NestJS recomendado):
  - `<nombre>.module.ts`
  - `<nombre>.controller.ts` ‚Üí maneja HTTP, no l√≥gica de negocio.
  - `<nombre>.service.ts` ‚Üí contiene la l√≥gica de negocio.
  - `<nombre>.repository.ts` ‚Üí s√≥lo acceso a DB (Prisma).
  - `<nombre>.schemas.ts` ‚Üí esquemas `zod` + tipos de dominio.
- **Regla de responsabilidad**:
  - Controllers: parsean input, llaman a services, devuelven respuestas tipadas.
  - Services: implementan reglas de negocio.
  - Repositories: s√≥lo queries a base de datos.
  - No poner l√≥gica de negocio en controllers ni en repositories.

### Contratos y API

- Dise√±ar la API pensando en el frontend Next.js que ya existe:
  - `GET /products` ‚Üí listado + filtros (marca, talle, etc.).
  - `GET /products/:id` ‚Üí detalle de producto.
  - `POST /auth/register` ‚Üí alta de usuario.
  - `POST /auth/login` ‚Üí devuelve tokens (access + refresh).
  - `GET /auth/profile` ‚Üí datos del usuario autenticado.
  - `POST /orders` ‚Üí crear orden/checkout a partir de items del carrito.
  - `GET /orders/:id` ‚Üí ver orden (s√≥lo due√±o de la orden).
- Responses consistentes:
  - En endpoints de listado, usar estructura:
    - `data`: array de entidades.
    - `meta`: paginaci√≥n, filtros, totales.
  - En endpoints de detalle, usar siempre objeto con `data`.

Ejemplo de respuesta de listado:

````jsonc
{
  "data": [ /* productos */ ],
  "meta": {
    "page": 1,
    "limit": 12,
    "total": 48
  }
}
Validaci√≥n y tipos (backend)
Validar SIEMPRE input de body, query y params con Zod.

No aceptar datos sin parseo previo (unknown ‚Üí parse ‚Üí tipo fuerte).

Esquemas Zod en *.schemas.ts, exportando tipos derivados con z.infer.

No usar any. Si es necesario, usar unknown y tipar con Zod.

Errores y logging (backend)
Manejo de errores centralizado:

Filtros globales / middlewares de error.

Mapear errores de validaci√≥n a HTTP 400/422.

Mapear errores de auth a 401/403.

No devolver stack traces ni detalles internos al cliente.

Loguear errores con contexto (ruta, userId, payload relevante).

Testing backend
Tests unitarios:

Services testeados en aislamiento (repository mockeado).

Tests de integraci√≥n:

Endpoints clave: login, registro, checkout, listado de productos.

Usar Supertest para levantar la app y golpear rutas reales.

No agregar features nuevas en el backend sin al menos:

Un test unitario para la l√≥gica.

Y/o un test de integraci√≥n para la ruta relevante.

Seguridad
Hashear contrase√±as (bcrypt o similar). Nunca guardar texto plano.

JWT con expiraciones razonables y refresh tokens persistidos/revocados.

No loguear contrase√±as ni tokens.

Revisar autorizaci√≥n:

Endpoints que leen/modifican recursos sensibles deben validar ownership (ej.: √≥rdenes del usuario).

CORS configurado expl√≠citamente seg√∫n entorno (dev/prod).

Integraci√≥n frontend ‚Üî backend
Mantener contratos estables:

Si cambia un endpoint usado por el frontend, actualizar tipos compartidos y adaptadores.

Idealmente, compartir tipos de dominio (Product, Order, User) en un paquete com√∫n (packages/core) o archivo de tipos compartidos.

El frontend debe consumir la API desde:

Server Components cuando sea posible (fetch en el servidor).

Rutas internas de Next s√≥lo cuando se necesite proxy especial.

Pull Requests / Commits
Commits peque√±os y descriptivos.

Seguir convenciones tipo Conventional Commits cuando sea posible.

No se acepta PR sin tests si afecta UI cr√≠tica, l√≥gica de dominio o endpoints del backend.

yaml
Copiar c√≥digo

---

## üß† Prompt para que Cursor empiece a crear el backend ‚Äúde a poco‚Äù

Este prompt es para que se lo pegues a Cursor en el repo del backend (o cuando armes `/apps/api` si vas a monorepo):

```md
Actu√° como un Backend Senior especializado en Node.js, TypeScript, NestJS y Prisma.

Contexto:
- Estoy construyendo el backend de un e-commerce de zapatillas sostenibles llamado "Zapatillas".
- El frontend ya existe en Next.js con TypeScript y consume un cat√°logo de productos.
- Quiero un backend separado, en Node.js + TypeScript, con arquitectura modular y nivel "empresa".
- Las reglas generales de arquitectura y calidad est√°n definidas en el archivo `.cursorrules` (ya creado en el repo).

Objetivo:
- Crear este backend **de a poco**, en pasos chicos y seguros:
  - Primero estructura base del proyecto.
  - Despu√©s configuraci√≥n de TypeScript, env, Prisma y PostgreSQL.
  - Luego m√≥dulo `products` (listado + detalle).
  - M√°s adelante auth, users y orders.

Modo de trabajo que quiero:
1. Primero, propon√© un plan de pasos peque√±os (una lista ordenada de tareas).
2. Ejecut√° cada paso de forma iterativa:
   - Explica brevemente qu√© vas a hacer.
   - Modifica/cree los archivos necesarios.
   - Indica qu√© comandos debo correr (por ejemplo: `npm install`, `npx prisma init`, etc.).
3. Despu√©s de cada bloque de cambios, asegurate de:
   - Que compile.
   - Que los archivos queden ordenados y tipados.
   - Agregar comments puntuales s√≥lo donde ayuden a entender la arquitectura.

Condiciones:
- Usar TypeScript estricto (sin `any`).
- Usar NestJS como framework HTTP, salvo que encuentre un bloqueo muy fuerte.
- Usar Prisma con PostgreSQL para el acceso a datos.
- Validar siempre el input con Zod o DTOs consistentes.
- Preparar desde el inicio la estructura para estos m√≥dulos: `products`, `users`, `auth`, `orders`, aunque no los implemente todos juntos.

Primera tarea que quiero que ejecutes ahora:
- Crear la estructura base del proyecto backend:
  - Inicializar proyecto NestJS con TypeScript.
  - Agregar configuraci√≥n b√°sica de `tsconfig`, `eslint` y `scripts` en `package.json`.
  - Crear un README breve explicando que este repo es el backend de "Zapatillas".
  - No implementar todav√≠a l√≥gica de negocio, s√≥lo el esqueleto m√≠nimo para que corra `npm run start:dev`.

Al final de esta primera iteraci√≥n:
- Mostrame un resumen de los archivos nuevos o modificados.
- Indicame qu√© comando exacto tengo que ejecutar para correr el servidor de desarrollo
````
